// Plugin by MySquadStats.com - @psg_ignis
// DO NOT EDIT THIS FILE WITHOUT CONSULTING MYSQUADSTATS

import axios from 'axios';
import { fileURLToPath } from 'url';
import path from 'path';
import fs from 'fs';

import BasePlugin from './base-plugin.js';

const currentVersion = 'v6.0.1';

export default class MySquadStats extends BasePlugin {
  static get description() {
    return 'The <code>MySquadStats.com</code> plugin will log various server statistics and events to a central database for player stat tracking.';
  }

  static get defaultEnabled() {
    return false;
  }

  static get optionsSpecification() {
    return {
      accessToken: {
        required: true,
        description: 'The access token to use for the database.',
        default: 'YOUR_ACCESS_TOKEN', // DO NOT MODIFY THIS - Change this in config.json!
      },
      allowInGameStatsCommand: {
        required: false,
        description:
          'Allow players to check their stats in-game via an AdminWarn.',
      },
      allowSimpleStatsCommand: {
        required: false,
        description:
          'Allow players to check their stats in-game via !stats as well as !mss stats.',
      },
    };
  }

  constructor(server, options, connectors) {
    super(server, options, connectors);

    this.onChatCommand = this.onChatCommand.bind(this);
    this.onRoundEnded = this.onRoundEnded.bind(this);
    this.onNewGame = this.onNewGame.bind(this);
    this.onPlayerConnected = this.onPlayerConnected.bind(this);
    this.onPlayerWounded = this.onPlayerWounded.bind(this);
    this.onPlayerDied = this.onPlayerDied.bind(this);
    this.onPlayerRevived = this.onPlayerRevived.bind(this);
    this.isProcessingFailedRequests = false;
    this.connectedPlayers = {};
    // Killstreaks
    this.trackedKillstreaks = {};
    this.killstreakWounded = this.killstreakWounded.bind(this);
    this.killstreakDied = this.killstreakDied.bind(this);
    this.killstreakNewGame = this.killstreakNewGame.bind(this);
    this.killstreakDisconnected = this.killstreakDisconnected.bind(this);
  }

  async prepareToMount() {}

  async mount() {
    // Post Request to create Server in API
    let dataType = 'servers';
    const serverData = {
      name: this.server.serverName,
      version: currentVersion,
    };
    const response = await postDataToAPI(
      dataType,
      serverData,
      this.options.accessToken
    );
    this.verbose(1, `Mount-Server | ${response.status} | ${response.message}`);

    // GET Request to get Match Info from API
    dataType = 'matches';
    const matchResponse = await getDataFromAPI(
      dataType,
      this.options.accessToken
    );
    this.match = matchResponse.match;
    this.verbose(
      1,
      `Mount-Match | ${matchResponse.status} | ${matchResponse.message}`
    );

    // Get currently connected players
    const players = await this.server.rcon.getListPlayers();
    // For each player, get their MSS ID
    for (const player of players) {
      if (!player.steamID) continue;
      // Patch Request to create Player in API
      const dataType = 'players';
      const playerData = {
        eosID: player.eosID,
        steamID: player.steamID,
        lastName: player.name,
        lastIP: player.ip,
      };
      const playerResponse = await patchDataInAPI(
        dataType,
        playerData,
        this.options.accessToken
      );
      if (playerResponse.status === 'Error') {
        this.verbose(
          1,
          `Mount-Player | ${playerResponse.status} | ${playerResponse.message}`
        );
      } else if (playerResponse.status === 'Success') {
        // Add to connected Players
        this.connectedPlayers[player.steamID] = {
          mssID: playerResponse.data.mssID,
        };
      }
    }

    // Subscribe to events
    this.server.on(`CHAT_COMMAND:mss`, this.onChatCommand);
    this.server.on(`CHAT_COMMAND:stats`, this.onChatCommand);
    this.server.on('ROUND_ENDED', this.onRoundEnded);
    this.winningTeamTracking = {};
    this.server.on('NEW_GAME', this.onNewGame);
    this.server.on('PLAYER_CONNECTED', this.onPlayerConnected);
    this.server.on('PLAYER_WOUNDED', this.onPlayerWounded);
    this.server.on('PLAYER_DIED', this.onPlayerDied);
    this.server.on('PLAYER_REVIVED', this.onPlayerRevived);
    this.server.on('PLAYER_WOUNDED', this.killstreakWounded);
    this.server.on('PLAYER_DIED', this.killstreakDied);
    this.server.on('NEW_GAME', this.killstreakNewGame);
    this.server.on('PLAYER_DISCONNECTED', this.killstreakDisconnected);
    // Check for updates in GitHub
    this.checkVersion();
    // Every 1 minute, ping MySquadStats
    this.pingInterval = setInterval(this.pingMySquadStats.bind(this), 60000);
    // Every 30 minutes, send Admins and Whitelisters to MySquadStats
    this.getAdminsInterval = setInterval(this.getAdmins.bind(this), 1800000);
    this.getPlayersInterval = setInterval(this.getPlayers.bind(this), 60000);
  }

  async unmount() {
    this.server.removeEventListener(`CHAT_COMMAND:mss`, this.onChatCommand);
    this.server.removeEventListener(`CHAT_COMMAND:stats`, this.onChatCommand);
    this.server.removeEventListener('ROUND_ENDED', this.onRoundEnded);
    this.server.removeEventListener('NEW_GAME', this.onNewGame);
    this.server.removeEventListener('PLAYER_CONNECTED', this.onPlayerConnected);
    this.server.removeEventListener('PLAYER_WOUNDED', this.onPlayerWounded);
    this.server.removeEventListener('PLAYER_DIED', this.onPlayerDied);
    this.server.removeEventListener('PLAYER_REVIVED', this.onPlayerRevived);
    this.server.removeEventListener('PLAYER_WOUNDED', this.killstreakWounded);
    this.server.removeEventListener('PLAYER_DIED', this.killstreakDied);
    this.server.removeEventListener('NEW_GAME', this.killstreakNewGame);
    this.server.removeEventListener(
      'PLAYER_DISCONNECTED',
      this.killstreakDisconnected
    );
    clearInterval(this.pingInterval);
    clearInterval(this.getAdminsInterval);
    clearInterval(this.getPlayersInterval);
  }

  async checkVersion(latestVersion) {
    const owner = 'Ignis-Bots';
    const repo = 'SquadJS-My-Squad-Stats';

    if (!latestVersion) {
      try {
        latestVersion = await getLatestVersion(owner, repo);
      } catch (error) {
        this.verbose(
          1,
          `Error retrieving the latest version of ${repo} from ${owner}:`,
          error
        );
      }
    }

    const __DataDirname = fileURLToPath(import.meta.url);
    // Create Update Cleared File
    const updateClearedFilePath = path.join(
      __DataDirname,
      '..',
      '..',
      'MySquadStats_Data',
      'update-cleared.json'
    );

    // Create the directory if it does not exist
    const dir = path.dirname(updateClearedFilePath);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }

    // Create Update Cleared if not exists with cleared: false
    if (!fs.existsSync(updateClearedFilePath)) {
      const data = JSON.stringify({ cleared: false }, null, 2);
      fs.writeFileSync(updateClearedFilePath, data);
    }

    const updateCleared = JSON.parse(fs.readFileSync(updateClearedFilePath));
    if (!updateCleared.cleared) {
      // Delete old Retry json Files due to potential conflicting changes in the code
      const retryPostFilePath = path.join(
        __DataDirname,
        '..',
        '..',
        'MySquadStats_Data',
        'send-retry-requests.json'
      );
      if (fs.existsSync(retryPostFilePath)) {
        fs.unlinkSync(retryPostFilePath);
      }

      const retryPatchFilePath = path.join(
        __DataDirname,
        '..',
        '..',
        'MySquadStats_Data',
        'patch-retry-requests.json'
      );
      if (fs.existsSync(retryPatchFilePath)) {
        fs.unlinkSync(retryPatchFilePath);
      }

      // Create/Update the update-cleared.json file
      fs.writeFileSync(
        updateClearedFilePath,
        JSON.stringify({ cleared: true })
      );
    }

    const comparisonResult = await compareVersions(
      currentVersion,
      latestVersion
    );

    if (comparisonResult < 0) {
      this.verbose(1, `A new version of ${repo} is available. Updating...`);

      const updatedCodeUrl = `https://raw.githubusercontent.com/${owner}/${repo}/${latestVersion}/squad-server/plugins/my-squad-stats.js`;

      // Download the updated code
      let updatedCode;
      try {
        const response = await axios.get(updatedCodeUrl);
        updatedCode = response.data;
      } catch (error) {
        this.verbose(
          1,
          `Error downloading the updated plugin for ${repo}:`,
          error
        );
        return;
      }

      const __dirname = path.dirname(fileURLToPath(import.meta.url));
      const filePath = path.join(__dirname, 'my-squad-stats.js');
      fs.writeFileSync(filePath, updatedCode);

      // Set the update-cleared.json file to false
      fs.writeFileSync(
        updateClearedFilePath,
        JSON.stringify({ cleared: false })
      );

      this.verbose(
        1,
        `Successfully updated ${repo} to version ${latestVersion}. Please restart the Node.js process to apply the changes.`
      );
    } else if (comparisonResult > 0) {
      this.verbose(
        1,
        `You are running a newer version of ${repo} than the latest version.\nThis likely means you are running a pre-release or beta version.\nYour Current Version: ${currentVersion} Latest Version: ${latestVersion}\nhttps://github.com/${owner}/${repo}/releases`
      );
    } else if (comparisonResult === 0) {
      this.verbose(1, `You are running the latest version of ${repo}.`);
    } else {
      this.verbose(1, `Unable to check for updates in ${repo}.`);
    }
    return;
  }

  async pingMySquadStats() {
    this.verbose(1, 'Pinging MySquadStats...');
    if (this.isProcessingFailedRequests) {
      this.verbose(1, 'Already processing failed requests...');
      return;
    }
    this.isProcessingFailedRequests = true;

    const __dirname = fileURLToPath(import.meta.url);
    const dataType = 'ping';
    const response = await getDataFromAPI(dataType, this.options.accessToken);
    if (response.message === 'pong') {
      this.verbose(1, 'Pong! MySquadStats is up and running.');

      const serverPluginVersion = response.data.serverPluginVersion;
      // Check Version
      this.checkVersion(serverPluginVersion);

      const postFilePath = path.join(
        __dirname,
        '..',
        '..',
        'MySquadStats_Data',
        'send-retry-requests.json'
      );
      if (fs.existsSync(postFilePath)) {
        this.verbose(1, `Retrying failed requests from ${postFilePath}...`);
        const completed = await retryFailedRequests(
          postFilePath,
          retryPostDataToAPI,
          this.options.accessToken
        );
        this.verbose(1, completed);
      }

      const patchFilePath = path.join(
        __dirname,
        '..',
        '..',
        'MySquadStats_Data',
        'patch-retry-requests.json'
      );
      if (fs.existsSync(patchFilePath)) {
        this.verbose(1, `Retrying failed requests from ${patchFilePath}...`);
        const completed = await retryFailedRequests(
          patchFilePath,
          retryPatchDataInAPI,
          this.options.accessToken
        );
        this.verbose(1, completed);
      }
    }
    this.isProcessingFailedRequests = false;
    return;
  }

  async getAdmins() {
    this.verbose(1, 'Getting Admins...');
    const adminLists = this.server.options.adminLists;
    const groups = {};
    const admins = {};
    const __dirname = fileURLToPath(import.meta.url);

    for (const [idx, list] of adminLists.entries()) {
      let data = '';
      try {
        switch (list.type) {
          case 'remote': {
            const resp = await axios({
              method: 'GET',
              url: `${list.source}`,
            });
            data = resp.data;
            break;
          }
          case 'local': {
            const listPath = path.resolve(__dirname, '../../../', list.source);
            if (!fs.existsSync(listPath))
              throw new Error(`Could not find Admin List at ${listPath}`);
            data = fs.readFileSync(listPath, 'utf8');
            break;
          }
          default:
            throw new Error(`Unsupported AdminList type:${list.type}`);
        }
      } catch (error) {
        this.verbose(
          1,
          `Error fetching ${list.type} admin list: ${list.source}`,
          error
        );
      }

      const groupRgx =
        /(?<=^Group=)(?<groupID>.*?):(?<groupPerms>.*?)(?=(?:\r\n|\r|\n|\s+\/\/))/gm;
      const adminRgx =
        /(?<=^Admin=)(?<adminID>\d{17}|[a-f0-9]{32}):(?<groupID>\S+)(?:.*@(?<discordUsername>\S*))?/gm;

      for (const m of data.matchAll(groupRgx)) {
        groups[`${idx}-${m.groups.groupID}`] = m.groups.groupPerms
          .split(',')
          .map((perm) => perm.trim());
      }
      for (const m of data.matchAll(adminRgx)) {
        try {
          const group = groups[`${idx}-${m.groups.groupID}`];
          const perms = {};
          for (const groupPerm of group) perms[groupPerm.toLowerCase()] = true;

          const adminID = m.groups.adminID;
          const discordUsername = m.groups.discordUsername || null;

          if (adminID in admins) {
            admins[adminID] = Object.assign(admins[adminID], perms, {
              discordUsername,
            });
            this.verbose(
              3,
              `Merged duplicate Admin ${adminID} to ${Object.keys(
                admins[adminID]
              )}`
            );
          } else {
            admins[adminID] = Object.assign(perms, { discordUsername });
            this.verbose(
              3,
              `Added Admin ${adminID} with ${Object.keys(perms)}`
            );
          }
        } catch (error) {
          this.verbose(
            1,
            `Error parsing admin group ${m.groups.groupID} from admin list: ${list.source}`,
            error
          );
        }
      }
    }
    this.verbose(1, `${Object.keys(admins).length} Admins/Reserve loaded...`);

    // Post Request to Admins API
    const dataType = 'admins';
    const response = await postDataToAPI(
      dataType,
      admins,
      this.options.accessToken
    );

    if (response.status === 'Error') {
      this.verbose(
        1,
        `Admins-Admins | ${response.status} | ${response.message}`
      );
    } else {
      this.verbose(
        1,
        `Admins-Admins | ${response.status} | ${response.message}`
      );
    }
    return;
  }

  async getPlayers() {
    this.verbose(1, 'Getting Players...');
    const publicSlots = this.server.publicSlots;
    const reserveSlots = this.server.reserveSlots;
    const publicQueue = this.server.publicQueue;
    const reserveQueue = this.server.reserveQueue;

    const players = await this.server.rcon.getListPlayers();
    let squads = await this.server.rcon.getSquads();

    // Ensure squads is always an array
    if (!Array.isArray(squads)) {
      this.verbose(
        1,
        'No squads found or error fetching squads, initializing as empty array.'
      );
      squads = [];
    }

    // Get Match ID
    const matchID = this.match && this.match.id ? this.match.id : null;

    // Initialize an object to hold teams
    const teams = {
      1: {
        teamID: '1',
        teamName: 'Team 1',
        matchID,
        publicSlots,
        reserveSlots,
        publicQueue,
        reserveQueue,
        squads: [
          {
            squadID: '0',
            squadName: 'Unassigned',
            teamID: '1',
            isCommandSquad: false,
            players: [],
          },
        ],
      },
      2: {
        teamID: '2',
        teamName: 'Team 2',
        matchID,
        publicSlots,
        reserveSlots,
        publicQueue,
        reserveQueue,
        squads: [
          {
            squadID: '0',
            squadName: 'Unassigned',
            teamID: '2',
            isCommandSquad: false,
            players: [],
          },
        ],
      },
    };

    // Iterate over each squad
    for (const squad of squads) {
      // Add the squad to the team
      if (teams[squad.teamID]) {
        // Build players array with mssID for each player in the squad
        const squadPlayers = [];
        for (const player of players) {
          if (
            player.squadID === squad.squadID &&
            player.teamID === squad.teamID
          ) {
            const playerMSSID = await this.getPlayerMSSID(player.steamID);
            squadPlayers.push({
              ...player,
              mssID: playerMSSID,
            });
          }
        }
        teams[squad.teamID].squads.push({
          ...squad,
          isCommandSquad: squad.squadName === 'Command Squad',
          players: squadPlayers,
        });
      } else {
        this.verbose(
          1,
          `Unknown teamID: ${squad.teamID}, squadID: ${squad.squadID}`
        );
      }
    }

    // Add unassigned players to the "Unassigned" squad
    for (const player of players) {
      if (teams[player.teamID]) {
        if (player.squadID === null) {
          const playerMSSID = await this.getPlayerMSSID(player.steamID);
          player.mssID = playerMSSID;
          teams[player.teamID].squads[0].players.push(player);
        }
      } else {
        this.verbose(
          1,
          `Unknown teamID: ${player.teamID}, playerID: ${player.id}`
        );
      }
    }

    // Update the size of the "Unassigned" squad
    for (const teamID in teams) {
      const unassignedSquad = teams[teamID].squads[0];
      unassignedSquad.size = unassignedSquad.players.length;
    }

    // Convert the teams object to an array
    const playersData = Object.values(teams);

    // POST serversPlayers to API
    const dataType = 'serversPlayers';
    const response = await postDataToAPI(
      dataType,
      playersData,
      this.options.accessToken
    );

    if (response.status === 'Error') {
      this.verbose(
        1,
        `Players-Players | ${response.status} | ${response.message}`
      );
    }
    return;
  }

  async onChatCommand(info) {
    // Get the message
    const message = info.message.toLowerCase();

    let simpleStatsCommand = false;
    if (
      this.options.allowSimpleStatsCommand === true &&
      info.raw.toLowerCase().endsWith('!stats')
    ) {
      simpleStatsCommand = true;
    }

    // Help Commands
    if (
      (message === 'help' ||
        message === 'commands' ||
        message === 'cmds' ||
        message === 'h' ||
        message.length === 0) &&
      simpleStatsCommand === false
    ) {
      let warningMessage = `Commands:`;
      if (this.options.allowInGameStatsCommand === true) {
        warningMessage += `\n!mss stats - Check your stats\nLogin to MySquadStats.com to Link`;
      } else {
        warningMessage += `\n!mss stats - Check your stats\nThis Server has disabled the in-game stats command.\nCheck your stats at MySquadStats.com`;
      }
      await this.server.rcon.warn(info.player.steamID, warningMessage);
    }

    if (message.startsWith('link')) {
      await this.server.rcon.warn(
        info.player.steamID,
        `Linking is now done on our website.\nLogin to MySquadStats.com to Link.`
      );
    } else if (message === 'stats' || simpleStatsCommand === true) {
      if (this.options.allowInGameStatsCommand === false) {
        return this.server.rcon.warn(
          info.player.steamID,
          `This Server has disabled the in-game stats command.\nCheck your stats at MySquadStats.com`
        );
      }

      // Get InGameStats from API
      const dataType = `inGameStats?search=${info.player.steamID}&dlc=${this.match.dlc}&layerClassname=${this.match.layerClassname}`;
      const statsResponse = await getDataFromAPI(
        dataType,
        this.options.accessToken
      );

      // Check if the response is valid
      if (
        !statsResponse ||
        !statsResponse.data ||
        statsResponse.data.length === 0
      ) {
        await this.server.rcon.warn(
          info.player.steamID,
          'Error: No stats data received.\nMySquadStats.com may be down.'
        );
        return;
      }

      // Extract the stats from the response
      const stats = statsResponse.data[0];

      await this.server.rcon.warn(
        info.player.steamID,
        `★ Season / All-Time ★\nWounds: ${stats.seasonWounds} / ${stats.totalWounds}\nKills: ${stats.seasonKills} / ${stats.totalKills}\nDeaths: ${stats.seasonDeaths} / ${stats.totalDeaths}\nRevives: ${stats.seasonRevives} / ${stats.totalRevives}\nHighest Killstreak: ${stats.seasonHighestKillstreak} / ${stats.totalHighestKillstreak}\n★ Stats are Delayed - MySquadStats.com ★`
      );
    }
    return;
  }

  async onRoundEnded(info) {
    // Initialize winning team tracking if not already done
    if (!this.winningTeamTracking) {
      this.winningTeamTracking = {
        team1: { consecutiveWins: 0, currentTeam: 1 },
        team2: { consecutiveWins: 0, currentTeam: 2 },
      };
    }

    // Patch Request to create Match in API
    const dataType = 'matches';
    let matchData = {};
    if (!info.winner || !info.loser) {
      // Reset both teams' winning streaks
      this.winningTeamTracking.team1.consecutiveWins = 0;
      this.winningTeamTracking.team2.consecutiveWins = 0;

      matchData = {
        endTime: info.time,
        winningTeamID: 0,
        winningTeam: 'Draw',
        winningSubfaction: 'Draw',
        winningStreak: 0,
        winningTickets: 0,
        losingTeamID: 0,
        losingTeam: 'Draw',
        losingSubfaction: 'Draw',
        losingTickets: 0,
      };
    } else {
      // Update winning streaks
      if (info.winner.team === this.winningTeamTracking.team1.currentTeam) {
        this.winningTeamTracking.team1.consecutiveWins += 1;
        this.winningTeamTracking.team2.consecutiveWins = 0;
      } else {
        this.winningTeamTracking.team2.consecutiveWins += 1;
        this.winningTeamTracking.team1.consecutiveWins = 0;
      }

      matchData = {
        endTime: info.time,
        winningTeamID: info.winner.team,
        winningTeam: info.winner.faction,
        winningSubfaction: info.winner.subfaction,
        winningStreak:
          info.winner.team === 1
            ? this.winningTeamTracking.team1.consecutiveWins
            : this.winningTeamTracking.team2.consecutiveWins,
        winningTickets: info.winner.tickets,
        losingTeamID: info.loser.team,
        losingTeam: info.loser.faction,
        losingSubfaction: info.loser.subfaction,
        losingTickets: info.loser.tickets,
      };

      const response = await patchDataInAPI(
        dataType,
        matchData,
        this.options.accessToken
      );
      if (response.status === 'Error') {
        this.verbose(
          1,
          `RoundEnded-Match | ${response.status} | ${response.message}`
        );
      }
    }

    // Swap team identifiers for the next round
    const temp = this.winningTeamTracking.team1.currentTeam;
    this.winningTeamTracking.team1.currentTeam =
      this.winningTeamTracking.team2.currentTeam;
    this.winningTeamTracking.team2.currentTeam = temp;

    return;
  }

  async onNewGame(info) {
    // Post Request to create Server in API
    let dataType = 'servers';
    const serverData = {
      name: this.server.serverName,
      version: currentVersion,
    };
    const serverResponse = await postDataToAPI(
      dataType,
      serverData,
      this.options.accessToken
    );
    this.verbose(
      1,
      `NewGame-Server | ${serverResponse.status} | ${serverResponse.message}`
    );

    // Post Request to create new Match in API
    dataType = 'matches';
    const newMatchData = {
      server: this.server.serverName,
      dlc: info.dlc,
      mapClassname: info.mapClassname,
      layerClassname: info.layerClassname,
      map: info.layer ? info.layer.map.name : null,
      layer: info.layer ? info.layer.name : null,
      startTime: info.time,
    };
    const matchResponse = await postDataToAPI(
      dataType,
      newMatchData,
      this.options.accessToken
    );
    this.match = matchResponse.match;
    if (matchResponse.status === 'Error') {
      this.verbose(
        1,
        `NewGame-Post-Match${matchResponse.status} | ${matchResponse.message}`
      );
    }
    return;
  }

  async onPlayerWounded(info) {
    // Get mssID from connectedPlayers
    let attackerMSSID = null;
    let victimMSSID = null;
    if (info.victim && info.victim.steamID) {
      victimMSSID = await this.getPlayerMSSID(info.victim.steamID);
    }
    if (info.attacker && info.attacker.steamID) {
      attackerMSSID = await this.getPlayerMSSID(info.attacker.steamID);
    }

    // Post Request to create Wound in API
    const dataType = 'wounds';
    const woundData = {
      match: this.match && this.match.id ? this.match.id : null,
      time: info.time,
      victim: info.victim ? info.victim.steamID : null,
      victimMSSID: victimMSSID,
      victimEosID: info.victim ? info.victim.eosID : null,
      victimName: info.victim ? info.victim.name : null,
      victimTeamID: info.victim ? info.victim.teamID : null,
      victimSquadID: info.victim ? info.victim.squadID : null,
      attacker: info.attacker ? info.attacker.steamID : null,
      attackerMSSID: attackerMSSID,
      attackerEosID: info.attacker ? info.attacker.eosID : null,
      attackerName: info.attacker ? info.attacker.name : null,
      attackerTeamID: info.attacker ? info.attacker.teamID : null,
      attackerSquadID: info.attacker ? info.attacker.squadID : null,
      damage: info.damage,
      weapon: info.weapon,
      teamkill: info.teamkill,
    };
    const response = await postDataToAPI(
      dataType,
      woundData,
      this.options.accessToken
    );
    if (response.status === 'Error') {
      this.verbose(
        1,
        `Wounds-Wound | ${response.status} | ${response.message}`
      );
    }
    return;
  }

  async onPlayerDied(info) {
    // Get mssID from connectedPlayers
    let attackerMSSID = null;
    let victimMSSID = null;
    if (info.victim && info.victim.steamID) {
      attackerMSSID = await this.getPlayerMSSID(info.victim.steamID);
    }
    if (info.attacker && info.attacker.steamID) {
      victimMSSID = await this.getPlayerMSSID(info.attacker.steamID);
    }

    if (info.victim) {
      // Post Request to create Death in API
      const dataType = 'deaths';
      const deathData = {
        match: this.match && this.match.id ? this.match.id : null,
        time: info.time,
        woundTime: info.woundTime,
        victim: info.victim ? info.victim.steamID : null,
        victimMSSID: victimMSSID,
        victimEosID: info.victim ? info.victim.eosID : null,
        victimName: info.victim ? info.victim.name : null,
        victimTeamID: info.victim ? info.victim.teamID : null,
        victimSquadID: info.victim ? info.victim.squadID : null,
        attacker: info.attacker ? info.attacker.steamID : null,
        attackerMSSID: attackerMSSID,
        attackerEosID: info.attacker ? info.attacker.eosID : null,
        attackerName: info.attacker ? info.attacker.name : null,
        attackerTeamID: info.attacker ? info.attacker.teamID : null,
        attackerSquadID: info.attacker ? info.attacker.squadID : null,
        damage: info.damage,
        weapon: info.weapon,
        teamkill: info.teamkill,
      };
      const response = await postDataToAPI(
        dataType,
        deathData,
        this.options.accessToken
      );
      if (response.status === 'Error') {
        this.verbose(
          1,
          `Died-Death | ${response.status} | ${response.message}`
        );
      }
    }
    return;
  }

  async onPlayerRevived(info) {
    // Get mssID from connectedPlayers
    let reviverMSSID = null;
    let attackerMSSID = null;
    let victimMSSID = null;
    if (info.reviver && info.reviver.steamID) {
      reviverMSSID = await this.getPlayerMSSID(info.reviver.steamID);
    }
    if (info.attacker && info.attacker.steamID) {
      attackerMSSID = await this.getPlayerMSSID(info.attacker.steamID);
    }
    if (info.victim && info.victim.steamID) {
      victimMSSID = await this.getPlayerMSSID(info.victim.steamID);
    }

    // Post Request to create Revive in API
    const dataType = 'revives';
    const reviveData = {
      match: this.match && this.match.id ? this.match.id : null,
      time: info.time,
      woundTime: info.woundTime,
      victim: info.victim ? info.victim.steamID : null,
      victimMSSID: victimMSSID,
      victimEosID: info.victim ? info.victim.eosID : null,
      victimName: info.victim ? info.victim.name : null,
      victimTeamID: info.victim ? info.victim.teamID : null,
      victimSquadID: info.victim ? info.victim.squadID : null,
      attacker: info.attacker ? info.attacker.steamID : null,
      attackerMSSID: attackerMSSID,
      attackerEosID: info.attacker ? info.attacker.eosID : null,
      attackerName: info.attacker ? info.attacker.name : null,
      attackerTeamID: info.attacker ? info.attacker.teamID : null,
      attackerSquadID: info.attacker ? info.attacker.squadID : null,
      damage: info.damage,
      weapon: info.weapon,
      teamkill: info.teamkill,
      reviver: info.reviver ? info.reviver.steamID : null,
      reviverMSSID: reviverMSSID,
      reviverEosID: info.reviver ? info.reviver.eosID : null,
      reviverName: info.reviver ? info.reviver.name : null,
      reviverTeamID: info.reviver ? info.reviver.teamID : null,
      reviverSquadID: info.reviver ? info.reviver.squadID : null,
    };
    const response = await postDataToAPI(
      dataType,
      reviveData,
      this.options.accessToken
    );
    if (response.status === 'Error') {
      this.verbose(
        1,
        `Revives-Revive | ${response.status} | ${response.message}`
      );
    }
    return;
  }

  async onPlayerConnected(info) {
    if (!info.player || !info.player.steamID) {
      return this.verbose(1, 'ERROR: Connected-Player | No SteamID');
    }
    let playerData = {};
    if (
      this.server.a2sPlayerCount <= 50 &&
      this.server.currentLayer &&
      this.server.currentLayer.gamemode === 'Seed'
    ) {
      playerData = {
        isSeeder: 1,
      };
    }

    // Patch Request to create Player in API
    const dataType = 'players';
    playerData = {
      ...playerData,
      eosID: info.player.eosID,
      steamID: info.player.steamID,
      lastName: info.player.name,
      lastIP: info.ip,
    };
    const response = await patchDataInAPI(
      dataType,
      playerData,
      this.options.accessToken
    );
    if (response.status === 'Error') {
      this.verbose(
        1,
        `Connected-Player | ${response.status} | ${response.message}`
      );
    } else if (response.status === 'Success') {
      // Add to connected Players
      this.connectedPlayers[info.player.steamID] = {
        mssID: response.data.mssID,
      };
    }
    return;
  }

  // KILLSTREAKS
  async killstreakWounded(info) {
    if (!info.attacker) return;
    if (info.teamkill === true) return;

    // Get the attacker's Steam ID
    const steamID = info.attacker.steamID;

    // Check if this is the first time the attacker has made a killstreak
    if (!this.trackedKillstreaks.hasOwnProperty(steamID)) {
      // Set the player's initial killstreak to 0
      this.trackedKillstreaks[steamID] = 0;
    }

    // Increment the player's kill streak by 1
    this.trackedKillstreaks[steamID] += 1;
  }

  async killstreakDied(info) {
    if (!info.victim) return;
    // GC Driod Support
    // Geonosian Hive
    const gcDroidFactions = [
      'Droid Army',
      'Droid Army - Lego',
      'Droid Army - SpecOps',
      'Droid Army - Camo',
      'Droid Army - Snow',
      'Droid Army - Mech',
      'Droid Army - Halloween',
      'Droid Army - Geonosis',
    ];
    // If info.victim.squad.teamName is in gcDroidFactions
    if (gcDroidFactions.includes(info?.victim?.squad?.teamName)) {
      this.verbose(2, `Droid Army Detected: ${info.victim.squad.teamName}`);
      // Call the onWound function with the info object
      this.killstreakWounded(info);
    }
    const steamID = info.victim.steamID;
    // Update highestKillstreak in the SQL database and get the new highestKillstreak
    await this.updateHighestKillstreak(steamID);

    if (this.trackedKillstreaks.hasOwnProperty(steamID)) {
      delete this.trackedKillstreaks[steamID];
    }
  }

  async killstreakNewGame(info) {
    // Get an array of all the Steam IDs in the trackedKillstreaks object
    const steamIDs = Object.keys(this.trackedKillstreaks);

    // Loop through the array
    for (const steamID of steamIDs) {
      if (this.trackedKillstreaks[steamID] > 0) {
        // Update highestKillstreak in the SQL database
        await this.updateHighestKillstreak(steamID);
      }

      // Remove the player from the trackedKillstreaks object
      delete this.trackedKillstreaks[eosID];
    }
    return;
  }

  async killstreakDisconnected(info) {
    if (!info.player.steamID) return;
    const steamID = info.player.steamID;

    // Update highestKillstreak in the SQL database
    if (this.trackedKillstreaks.hasOwnProperty(steamID)) {
      if (this.trackedKillstreaks[steamID] > 0) {
        await this.updateHighestKillstreak(steamID);
      }
    }

    delete this.trackedKillstreaks[steamID];

    // Remove from connectedPlayers
    if (this.connectedPlayers.hasOwnProperty(info.player.steamID)) {
      delete this.connectedPlayers[info.player.steamID];
    }
  }

  async updateHighestKillstreak(steamID) {
    // Get the player's current killstreak from the trackedKillstreaks object
    const currentKillstreak = this.trackedKillstreaks[steamID];

    // Return is the player's current killstreak is 0
    if (!currentKillstreak || currentKillstreak === 0) return;

    // Get mssID from connectedPlayers
    const mssID = await this.getPlayerMSSID(steamID);
    try {
      // Patch Request to update highestKillstreak in API
      const dataType = 'playerKillstreaks';
      const playerData = {
        steamID: steamID,
        mssID: mssID,
        highestKillstreak: currentKillstreak,
        match: this.match && this.match.id ? this.match.id : null,
      };
      const response = await patchDataInAPI(
        dataType,
        playerData,
        this.options.accessToken
      );
      if (response.status === 'Error') {
        this.verbose(
          1,
          `Error updating highestKillstreak in database for ${steamID}: ${response.message}`
        );
      }
    } catch (error) {
      this.verbose(
        1,
        `Error updating highestKillstreak in database for ${steamID}: ${error}`
      );
    }
    return;
  }

  async getPlayerMSSID(steamID) {
    if (this.connectedPlayers.hasOwnProperty(steamID)) {
      return this.connectedPlayers[steamID].mssID;
    } else {
      return null;
    }
  }
}

// Retrieve the latest version of code from GitHub
async function getLatestVersion(owner, repo) {
  const url = `https://api.github.com/repos/${owner}/${repo}/releases/latest`;
  const response = await fetch(url);
  const data = await response.json();
  return data.tag_name;
}

async function compareVersions(version1, version2) {
  const v1Parts = version1.replace('v', '').split('.').map(Number);
  const v2Parts = version2.replace('v', '').split('.').map(Number);

  for (let i = 0; i < Math.max(v1Parts.length, v2Parts.length); i++) {
    const v1 = v1Parts[i] || 0;
    const v2 = v2Parts[i] || 0;

    if (v1 > v2) return 1;
    if (v1 < v2) return -1;
  }

  return 0;
}

function handleApiError(error) {
  if (error.response) {
    let errMsg = `${error.response.status} - ${error.response.statusText}`;
    const status = 'Error';
    if (error.response.status === 502) {
      errMsg += ' Unable to connect to the API. MySquadStats is likely down.';
    } else if (error.response.status === 500) {
      errMsg += ' Internal server error. Something went wrong on the server.';
    }
    return {
      status: status,
      message: errMsg,
    };
  } else if (error.request) {
    // The request was made but no response was received
    return {
      status: 'Error',
      message:
        // Added Status Page
        'No response received from the API. Please check network connections or https://status.mysquadstats.com/.',
    };
  } else {
    // Something happened in setting up the request that triggered an Error
    return {
      status: 'Error',
      message: `Error: ${error.message}`,
    };
  }
}

async function retryFailedRequests(filePath, apiFunction, accessToken) {
  let failedRequests = JSON.parse(fs.readFileSync(filePath));

  // Send Ping to MySquadStats with amount of failed requests
  const pingDataType = 'ping';
  const pingData = {
    filePath: filePath,
    failedRequests: failedRequests.length,
  };
  const pingResponse = await postDataToAPI(pingDataType, pingData, accessToken);
  console.log(
    `Ping-MySquadStats | ${pingResponse.status} | ${pingResponse.message}`
  );

  // Sort the array so that match requests come first
  failedRequests.sort((a, b) => {
    if (a.dataType === 'matches' && b.dataType !== 'matches') {
      return -1;
    } else if (a.dataType !== 'matches' && b.dataType === 'matches') {
      return 1;
    } else {
      return 0;
    }
  });

  for (let i = 0; i < failedRequests.length; i++) {
    const request = failedRequests[i];
    const retryResponse = await apiFunction(
      request.dataType,
      request.data,
      accessToken
    );
    console.log(`${retryResponse.status} | ${retryResponse.message}`);
    if (retryResponse.status === 'Success') {
      // Remove the request from the array
      failedRequests.splice(i, 1);
      // Decrement i so the next iteration won't skip an item
      i--;
      // Write the updated failedRequests array back to the file
      fs.writeFileSync(filePath, JSON.stringify(failedRequests));
    } else if (retryResponse.status === 'Error') {
      // Remove the request from the array
      failedRequests.splice(i, 1);
      // Decrement i so the next iteration won't skip an item
      i--;
      // Write the updated failedRequests array back to the file
      fs.writeFileSync(filePath, JSON.stringify(failedRequests));
    }
    // Wait for 5 seconds before processing the next request
    await new Promise((resolve) => setTimeout(resolve, 5000));
  }

  // Delete the file if there are no more failed requests
  if (failedRequests.length === 0) {
    fs.unlinkSync(filePath);
  }

  let completed = `Finished retrying failed requests from ${filePath}.`;
  return completed;
}

async function postDataToAPI(dataType, data, accessToken) {
  const __dirname = fileURLToPath(import.meta.url);
  try {
    const response = await axios.post(
      `https://api.mysquadstats.com/${dataType}`,
      data,
      {
        params: { accessToken },
      }
    );
    return response.data;
  } catch (error) {
    if (error.response && error.response.status === 502) {
      // Save the request details to a local file for later retry
      const requestDetails = {
        dataType: `${dataType}`,
        data: data,
      };
      const dirPath = path.join(__dirname, '..', '..', 'MySquadStats_Data');
      if (!fs.existsSync(dirPath)) {
        fs.mkdirSync(dirPath, { recursive: true });
      }

      const filePath = path.join(dirPath, 'send-retry-requests.json');
      let failedRequests = [];
      if (fs.existsSync(filePath)) {
        failedRequests = JSON.parse(fs.readFileSync(filePath));
      }
      failedRequests.push(requestDetails);
      fs.writeFileSync(filePath, JSON.stringify(failedRequests));
    }
    return handleApiError(error);
  }
}

async function patchDataInAPI(dataType, data, accessToken) {
  const __dirname = fileURLToPath(import.meta.url);
  try {
    const response = await axios.patch(
      `https://api.mysquadstats.com/${dataType}`,
      data,
      {
        params: { accessToken },
      }
    );
    return response.data;
  } catch (error) {
    if (error.response && error.response.status === 502) {
      // Save the request details to a local file for later retry
      const requestDetails = {
        dataType: `${dataType}`,
        data: data,
      };
      const dirPath = path.join(__dirname, '..', '..', 'MySquadStats_Data');
      if (!fs.existsSync(dirPath)) {
        fs.mkdirSync(dirPath, { recursive: true });
      }

      const filePath = path.join(dirPath, 'patch-retry-requests.json');
      let failedRequests = [];
      if (fs.existsSync(filePath)) {
        failedRequests = JSON.parse(fs.readFileSync(filePath));
      }
      failedRequests.push(requestDetails);
      fs.writeFileSync(filePath, JSON.stringify(failedRequests));
    }
    return handleApiError(error);
  }
}

async function getDataFromAPI(dataType, accessToken) {
  try {
    const response = await axios.get(
      `https://api.mysquadstats.com/${dataType}`,
      {
        params: { accessToken },
      }
    );
    return response.data;
  } catch (error) {
    return handleApiError(error);
  }
}

async function retryPostDataToAPI(dataType, data, accessToken) {
  try {
    const response = await axios.post(
      `https://api.mysquadstats.com/${dataType}`,
      data,
      {
        params: { accessToken },
      }
    );
    return response.data;
  } catch (error) {
    return handleApiError(error);
  }
}

async function retryPatchDataInAPI(dataType, data, accessToken) {
  try {
    const response = await axios.patch(
      `https://api.mysquadstats.com/${dataType}`,
      data,
      {
        params: { accessToken },
      }
    );
    return response.data;
  } catch (error) {
    return handleApiError(error);
  }
}
